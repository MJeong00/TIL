## JVM이란?
### 자바를 실행시키기 위한 가상 머신.  
java는 JVM을 거쳐 OS에 도달하므로 OS에 종속적이지 않다.  

 

=> .java 파일은 컴퓨터가 인식하지 못하므로 컴파일을 해줘야한다.
이 때 JVM이 인식할 수 있는 .class 파일(byte code)로 변환해주고, JVM이 byte code를 OS가 인식할 수 있도록 도와준다.  

![image](https://user-images.githubusercontent.com/108853290/200352311-331232cc-2312-4263-8f02-85dc7696132d.png)

------------------------------------------------
 
## JVM 구성 요소

![image](https://user-images.githubusercontent.com/108853290/200353384-c4903432-3b61-49e2-998f-cef4d9b7794a.png)

  
    1. 클래스 로더(Class Loader)
    2. 실행 엔진(Execution Engine)
      1. 인터프리터(Interpreter)
      2. JIT 컴파일러(Just-in-Time)
      3. 가비지 콜렉터(Garbage collector)
    3. 런타임 데이터 영역 (Runtime Data Area)
 

### 1) 클래스 로더 
- 런타임 시점에 JVM 내로 .class 파일을 메로리에 로드하는 역할을 담당한다.  
 

### 2) 실행 엔진
- 클래스를 실행시키는 역할
- 클래스 로더로부터 메모리에 올라온 파일들(.class)을 실제로 기계가 실행할 수 있는 코드로 변형키는 역할을 한다.

     - 인터프리터   
        - .class 파일을 명령어 단위로 읽어서 실행
        - 한 줄씩 실행해서 느리다는 단점이 있음
     - JIT (Just In Time)
        - 바이트 코드를 어셈블리같은 네이티브 코드로 바꿈으로서 실행이 빠르지만 변환하는데 비용이 발생

        - 때문에 JVM은 모든 코드를 JIM 방식으로 실행하지 않고 인터프리터 방식을 사용하다가 일정한 기준이 넘어가면 JIT 방식을 사용한다.
     - 가비지 컬렉터(GC)
        - 힙 메모리에서 더 이상 사용되지 않는 인스턴스를 찾아 메모리에서 삭제하는 역할을 하고 이로써 힙메모리를 재사용할 수 있게 된다는 장점을 가진다.
   
     

### 3) Runtime Data Area
- 프로그램을 수행하기 위해 OS에서 할당받은 메모리 공간으로 5가지로 구분된다.
  ![image](https://user-images.githubusercontent.com/108853290/200353460-e6387ba4-1ed2-48b6-81bf-6eca74a756f4.png)
  

  - Method Area
    - 모든 쓰레드가 공유하는 메모리 영역
    - .class파일을 메로리에 올릴 때 초기화되는 대상을 저장하기 위한 영역이다.

  - pc 레지스터
    - 쓰레드가 시작될 때 생성되며 쓰레드마다 하나씩 존재한다.
    - 쓰레드가 어떤 동작을 실행 하게 될지에 대한 부분을 저장한다.

  - Stack Area
    - 메소드 실행을 위해 임시로 할당되었다가 메소드 실행이 끝나면 소멸된다.
    - 메소드 실행 내에 변수, 매개변수 등에 필요한 메모리를 할당한다.

  - Heap Area
    - 객체를 저장하는 공간으로 new로 만들어진 객체와 배열을 저장한다.
    - 가비지 컬렉터의 대상 관리가 된다.

  - Native Stack Area
    - 컴퓨터가 실행시킬 수 있는 기계어로 작성된 프로그램을 실행시키는 영역이다.
